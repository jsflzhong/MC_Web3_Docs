# 1. Reference
https://ethereum.org/zh/developers/docs/smart-contracts/anatomy/


# 2. What
æ™ºèƒ½åˆçº¦æ˜¯ä¸€ç§åœ¨ä»¥å¤ªåŠæŸä¸ªåœ°å€ä¸Šè¿è¡Œçš„ç¨‹åºã€‚ 
å®ƒä»¬æ˜¯ç”±**æ•°æ®å’Œå‡½æ•°ç»„æˆçš„**ï¼Œå¯ä»¥åœ¨æ”¶åˆ°äº¤æ˜“æ—¶æ‰§è¡Œã€‚ ä»¥ä¸‹æ¦‚è¿°ä¸€ä¸ªæ™ºèƒ½åˆçº¦çš„ç»„æˆã€‚

å‰ææ¡ä»¶
ç¡®ä¿ä½ å·²ç»å…ˆé˜…è¯»äº†æ™ºèƒ½åˆçº¦ã€‚ æœ¬æ–‡æ¡£å‡è®¾ä½ å·²ç»ç†Ÿæ‚‰æŸç§ç¼–ç¨‹è¯­è¨€ï¼Œä¾‹å¦‚ JavaScript æˆ– Pythonã€‚


# 3. æ•°æ®
ä»»ä½•åˆçº¦æ•°æ®å¿…é¡»åˆ†é…åˆ°ä¸€ä¸ªä½ç½®ï¼š**è¦ä¹ˆæ˜¯å­˜å‚¨ï¼Œè¦ä¹ˆæ˜¯å†…å­˜**ã€‚ 

**åœ¨æ™ºèƒ½åˆçº¦ä¸­ä¿®æ”¹å­˜å‚¨æ¶ˆè€—å¾ˆå¤§ï¼Œå› æ­¤ä½ éœ€è¦è€ƒè™‘æ•°æ®åœ¨å“ªé‡Œå­˜å–ã€‚**

# 3.1 å­˜å‚¨
**æŒä¹…æ€§æ•°æ®è¢«ç§°ä¹‹ä¸ºå­˜å‚¨ï¼Œç”±çŠ¶æ€å˜é‡è¡¨ç¤º**ã€‚ 
è¿™äº›å€¼è¢«æ°¸ä¹…åœ°å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šã€‚ ä½ éœ€è¦å£°æ˜ä¸€ä¸ªç±»å‹ï¼Œä»¥ä¾¿äºåˆçº¦åœ¨ç¼–è¯‘æ—¶å¯ä»¥è·Ÿè¸ªå®ƒåœ¨åŒºå—é“¾ä¸Šéœ€è¦å¤šå°‘å­˜å‚¨ã€‚

```
// Solidity example
contract SimpleStorage {
    uint storedData; // State variable
    // ...
}
```

```
# Vyper example
storedData: int128
```

å¦‚æœç”¨è¿‡é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€ï¼Œåº”è¯¥ä¼šç†Ÿæ‚‰å¤§å¤šæ•°ç±»å‹ã€‚ ä½†å¦‚æœæ˜¯åˆšæ¥è§¦ä»¥å¤ªåŠå¼€å‘ï¼Œåˆ™ä¼šå‘ç° address æ˜¯ä¸€ä¸ªæ–°ç±»å‹ã€‚

ä¸€ä¸ª address ç±»å‹å¯ä»¥å®¹çº³ä¸€ä¸ªä»¥å¤ªåŠåœ°å€ï¼Œç›¸å½“äº 20 ä¸ªå­—èŠ‚æˆ– 160 ä½ã€‚ å®ƒä»¥åå…­è¿›åˆ¶çš„å½¢å¼è¿”å›ï¼Œå‰å¯¼æ˜¯ 0xã€‚

å…¶å®ƒç±»å‹åŒ…æ‹¬ï¼š

- å¸ƒå°”
- æ•´æ•°ï¼ˆintegerï¼‰
- å®šç‚¹æ•°ï¼ˆfixed point numbersï¼‰
- å›ºå®šå¤§å°çš„å­—èŠ‚æ•°ç»„ï¼ˆfixed-size byte arraysï¼‰
- åŠ¨æ€å¤§å°çš„å­—èŠ‚æ•°ç»„ï¼ˆdynamically-sized byte arraysï¼‰
- æœ‰ç†æ•°å’Œæ•´æ•°å¸¸é‡ï¼ˆRational and integer literalsï¼‰
- å­—ç¬¦å¸¸é‡ï¼ˆString literalsï¼‰
- åå…­è¿›åˆ¶å¸¸é‡ï¼ˆHexadecimal literalsï¼‰
- æšä¸¾ï¼ˆEnumsï¼‰
  
äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ–‡æ¡£ï¼š

æŸ¥çœ‹ Vyper ç±»å‹(opens in a new tab)
æŸ¥çœ‹ Solidity ç±»å‹(opens in a new tab)

# 3.2 å†…å­˜
ä»…åœ¨åˆçº¦å‡½æ•°æ‰§è¡ŒæœŸé—´å­˜å‚¨çš„å€¼è¢«ç§°ä¸ºå†…å­˜å˜é‡ã€‚ 
ç”±äºè¿™äº›å˜é‡ä¸æ˜¯æ°¸ä¹…åœ°å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šï¼Œæ‰€ä»¥å®ƒä»¬çš„ä½¿ç”¨æˆæœ¬è¦ä½å¾—å¤šã€‚

åœ¨ [Solidity æ–‡æ¡£](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html?highlight=memory#storage-memory-and-the-stack)ä¸­äº†è§£æ›´å¤šå…³äºä»¥å¤ªåŠè™šæ‹Ÿæœºå¦‚ä½•å­˜å‚¨æ•°æ®ï¼ˆå­˜å‚¨ã€å†…å­˜å’Œæ ˆï¼‰ã€‚

# 3.3 ç¯å¢ƒå˜é‡
é™¤äº†åœ¨è‡ªå·±åˆçº¦ä¸Šå®šä¹‰çš„å˜é‡ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›ç‰¹æ®Šçš„å…¨å±€å˜é‡ã€‚ å®ƒä»¬ä¸»è¦ç”¨äºæä¾›æœ‰å…³åŒºå—é“¾æˆ–å½“å‰äº¤æ˜“çš„ä¿¡æ¯ã€‚

ç¤ºä¾‹ï¼š

å±æ€§block.timestampï¼ŒçŠ¶æ€å˜é‡ï¼šuint256	æè¿°ï¼šå½“å‰åŒºå—çš„æ—¶é—´æˆ³
å±æ€§msg.sender	    çŠ¶æ€å˜é‡ï¼šåœ°å€	æè¿°ï¼šæ¶ˆæ¯çš„å‘é€è€…ï¼ˆå½“å‰è°ƒç”¨ï¼‰


# 4. å‡½æ•°
ç”¨æœ€ç®€å•çš„æœ¯è¯­æ¥è¯´ï¼Œå‡½æ•°å¯ä»¥è·å¾—ä¿¡æ¯æˆ–è®¾ç½®ä¿¡æ¯ï¼Œä»¥å“åº”ä¼ å…¥çš„äº¤æ˜“ã€‚

æœ‰ä¸¤ç§å‡½æ•°è°ƒç”¨æ–¹å¼ï¼š

- internal â€“ ä¸ä¼šåˆ›å»ºä»¥å¤ªåŠè™šæ‹Ÿæœºè°ƒç”¨
  - Internal å‡½æ•°å’ŒçŠ¶æ€å˜é‡åªèƒ½åœ¨å†…éƒ¨è®¿é—®ï¼ˆåªèƒ½åœ¨åˆçº¦å†…éƒ¨æˆ–è€…ä»å…¶ç»§æ‰¿çš„åˆçº¦å†…éƒ¨è®¿é—®ï¼‰ã€‚
  
- external â€“ ä¼šåˆ›å»ºä»¥å¤ªåŠè™šæ‹Ÿæœºè°ƒç”¨
  - External å‡½æ•°æ˜¯åˆçº¦æ¥å£çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ„å‘³ç€ä»–å¯ä»¥è¢«å…¶å®ƒåˆçº¦å’Œäº¤æ˜“è°ƒç”¨ã€‚ ä¸€ä¸ª external å‡½æ•° f ä¸å¯ä»¥è¢«å†…éƒ¨è°ƒç”¨ï¼ˆå³ f() ä¸è¡Œï¼Œä½† this.f() å¯ä»¥ï¼‰ã€‚


å®ƒä»¬å¯ä»¥æ˜¯ public æˆ– private

- public å‡½æ•°å¯ä»¥åœ¨åˆçº¦å†…éƒ¨è°ƒç”¨æˆ–è€…é€šè¿‡æ¶ˆæ¯åœ¨åˆçº¦å¤–éƒ¨è°ƒç”¨
- private å‡½æ•°ä»…åœ¨å…¶è¢«å®šä¹‰çš„åˆçº¦å†…éƒ¨å¯è§ï¼Œå¹¶ä¸”åœ¨è¯¥åˆçº¦çš„æ´¾ç”Ÿåˆçº¦ä¸­ä¸å¯è§ã€‚
  
å‡½æ•°å’ŒçŠ¶æ€å˜é‡éƒ½å¯ä»¥è¢«å®šä¹‰ä¸º public æˆ– private

ä¸‹é¢æ˜¯æ›´æ–°åˆçº¦ä¸Šä¸€ä¸ªçŠ¶æ€å˜é‡çš„å‡½æ•°ï¼š

```
// Solidity example
function update_name(string value) public {
    dapp_name = value;
}
```

string ç±»å‹çš„å‚æ•° value ä¼ å…¥å‡½æ•° update_name
å‡½æ•°å£°æ˜ä¸º publicï¼Œæ„å‘³ç€ä»»ä½•äººéƒ½èƒ½è®¿é—®å®ƒ
å‡½æ•°æ²¡æœ‰è¢«å£°æ˜ä¸º viewï¼Œå› æ­¤å®ƒå¯ä»¥ä¿®æ”¹åˆçº¦çŠ¶æ€

# 4.1 è§†å›¾å‡½æ•°
è¿™äº›å‡½æ•°ä¿è¯ä¸ä¼šä¿®æ”¹åˆçº¦æ•°æ®çš„çŠ¶æ€ã€‚ 
å¸¸è§çš„ç¤ºä¾‹æ˜¯ "getter" å‡½æ•° - ä¾‹å¦‚ï¼Œå®ƒå¯ä»¥ç”¨äºæ¥æ”¶ç”¨æˆ·çš„ä½™é¢ã€‚

// Solidity ç¤ºä¾‹
```
function balanceOf(address _owner) public view returns (uint256 _balance) {
    return ownerPizzaCount[_owner];
}
```
dappName: public(string)
@view
@public
def readName() -> string:
  return dappName

è¿™äº›æ“ä½œè¢«è§†ä¸ºä¿®æ”¹çŠ¶æ€ï¼š

- å†™å…¥çŠ¶æ€å˜é‡ã€‚
- æ­£åœ¨å¯¼å‡ºäº‹ä»¶(opens in a new tab)ã€‚
- åˆ›å»ºå…¶å®ƒåˆçº¦(opens in a new tab)ã€‚
- ä½¿ç”¨ selfdestructã€‚
- é€šè¿‡è°ƒç”¨å‘é€ etherã€‚
- è°ƒç”¨ä»»ä½•æœªæ ‡è®°ä¸º view æˆ– pure çš„å‡½æ•°ã€‚
- ä½¿ç”¨åº•å±‚è°ƒç”¨ã€‚
- ä½¿ç”¨åŒ…å«æŸäº›æ“ä½œç çš„å†…è”ç¨‹åºç»„ã€‚

# 4.2 æ„é€ å‡½æ•°
constructor å‡½æ•°åªåœ¨é¦–æ¬¡éƒ¨ç½²åˆçº¦æ—¶æ‰§è¡Œä¸€æ¬¡ã€‚ ä¸è®¸å¤šåŸºäºç±»çš„ç¼–ç¨‹è¯­è¨€ä¸­çš„ constructor å‡½æ•°ç±»ä¼¼ï¼Œè¿™äº›å‡½æ•°å¸¸å°†çŠ¶æ€å˜é‡åˆå§‹åŒ–åˆ°æŒ‡å®šçš„å€¼ã€‚

```
// Solidity ç¤ºä¾‹
// åˆå§‹åŒ–åˆçº¦æ•°æ®ï¼Œè®¾ç½® `owner`ä¸ºåˆçº¦çš„åˆ›å»ºè€…ã€‚
constructor() public {
    // æ‰€æœ‰æ™ºèƒ½åˆçº¦ä¾èµ–å¤–éƒ¨äº¤æ˜“æ¥è§¦å‘å…¶å‡½æ•°ã€‚
    // `msg` æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼ŒåŒ…å«äº†ç»™å®šäº¤æ˜“çš„ç›¸å…³æ•°æ®ï¼Œ
    // ä¾‹å¦‚å‘é€è€…çš„åœ°å€å’Œäº¤æ˜“ä¸­åŒ…å«çš„ ETH æ•°é‡ã€‚
    // äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/units-and-global-variables.html#block-and-transaction-properties
    owner = msg.sender;
}
```

# Vyper ç¤ºä¾‹
@external
def __init__(_beneficiary: address, _bidding_time: uint256):
    self.beneficiary = _beneficiary
    self.auctionStart = block.timestamp
    self.auctionEnd = self.auctionStart + _bidding_time


# 4.3 å†…ç½®å‡½æ•°
é™¤äº†è‡ªå·±åœ¨åˆçº¦ä¸­å®šä¹‰çš„å˜é‡å’Œå‡½æ•°å¤–ï¼Œè¿˜æœ‰ä¸€äº›ç‰¹æ®Šçš„å†…ç½®å‡½æ•°ã€‚ æœ€æ˜æ˜¾çš„ä¾‹å­æ˜¯ï¼š

address.send() â€“ Solidity
send(address) â€“ Vyper
è¿™ä½¿åˆçº¦å¯ä»¥å‘é€ä»¥å¤ªå¸ç»™å…¶å®ƒå¸æˆ·ã€‚


# 5. ç¼–å†™å‡½æ•°
ä½ çš„å‡½æ•°éœ€è¦ï¼š

å‚æ•°å˜é‡åŠå…¶ç±»å‹ï¼ˆå¦‚æœå®ƒæ¥å—å‚æ•°ï¼‰
- å£°æ˜ä¸º internal/external
- å£°æ˜ä¸º pure/view/payable
- è¿”å›ç±»å‹ï¼ˆå¦‚æœå®ƒè¿”å›å€¼ï¼‰

```
pragma solidity >=0.4.0 <=0.6.0;
contract ExampleDapp {
    string dapp_name; // state variable
    // Called when the contract is deployed and initializes the value
    constructor() public {
        dapp_name = "My Example dapp";
    }
    // Get Function
    function read_name() public view returns(string) {
        return dapp_name;
    }
    // Set Function
    function update_name(string value) public {
        dapp_name = value;
    }
}
```
ä¸€ä¸ªå®Œæ•´çš„åˆçº¦å¯èƒ½å°±æ˜¯è¿™æ ·ã€‚ åœ¨è¿™é‡Œï¼Œconstructor å‡½æ•°ä¸º dapp_name å˜é‡æä¾›äº†åˆå§‹åŒ–å€¼ã€‚


# 6. äº‹ä»¶å’Œæ—¥å¿—
äº‹ä»¶è®©ä½ çš„æ™ºèƒ½åˆçº¦èƒ½å¤Ÿä¸å‰ç«¯æˆ–å…¶ä»–è®¢é˜…åº”ç”¨ç¨‹åºè¿›è¡Œé€šä¿¡ã€‚ ä¸€æ—¦äº¤æ˜“è¢«éªŒè¯å¹¶æ·»åŠ åˆ°åŒºå—ä¸­ï¼Œæ™ºèƒ½åˆçº¦å°±å¯ä»¥è§¦å‘äº‹ä»¶å¹¶è®°å½•ä¿¡æ¯ï¼Œç„¶åå‰ç«¯å°±å¯ä»¥å¤„ç†å’Œåˆ©ç”¨è¿™äº›ä¿¡æ¯ã€‚


# 7. é™„å¸¦æ³¨è§£çš„ç¤ºä¾‹
è¿™æ˜¯ä¸€äº›ç”¨ Solidity å†™çš„ä¾‹å­ã€‚ å¦‚æœå¸Œæœ›è¿è¡Œè¿™äº›ä»£ç ï¼Œä½ å¯ä»¥åœ¨ Remix(opens in a new tab) ä¸­è°ƒè¯•ã€‚

# 7.1 Hello world

```
// Specifies the version of Solidity, using semantic versioning.
// äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/layout-of-source-files.html#pragma
pragma solidity ^0.5.10;
// å®šä¹‰åˆçº¦åç§° `HelloWorld`ã€‚
// ä¸€ä¸ªåˆçº¦æ˜¯å‡½æ•°å’Œæ•°æ®ï¼ˆå…¶çŠ¶æ€ï¼‰çš„é›†åˆã€‚
// ä¸€æ—¦éƒ¨ç½²ï¼Œåˆçº¦å°±ä¼šç•™åœ¨ä»¥å¤ªåŠåŒºå—é“¾çš„ä¸€ä¸ªç‰¹å®šåœ°å€ä¸Šã€‚
// äº†è§£æ›´å¤šï¼š https://solidity.readthedocs.io/en/v0.5.10/structure-of-a-contract.html
contract HelloWorld {
    // å®šä¹‰`string`ç±»å‹å˜é‡ `message`
    // çŠ¶æ€å˜é‡æ˜¯å…¶å€¼æ°¸ä¹…å­˜å‚¨åœ¨åˆçº¦å­˜å‚¨ä¸­çš„å˜é‡ã€‚
    // å…³é”®å­— `public` ä½¿å¾—å¯ä»¥ä»åˆçº¦å¤–éƒ¨è®¿é—®ã€‚
    // å¹¶åˆ›å»ºäº†ä¸€ä¸ªå…¶å®ƒåˆçº¦æˆ–å®¢æˆ·ç«¯å¯ä»¥è°ƒç”¨è®¿é—®è¯¥å€¼çš„å‡½æ•°ã€‚
    string public message;
    // ç±»ä¼¼äºå¾ˆå¤šåŸºäºç±»çš„é¢å‘å¯¹è±¡è¯­è¨€ï¼Œ
    // æ„é€ å‡½æ•°æ˜¯ä»…åœ¨åˆçº¦åˆ›å»ºæ—¶æ‰§è¡Œçš„ç‰¹æ®Šå‡½æ•°ã€‚
    // æ„é€ å™¨ç”¨äºåˆå§‹åŒ–åˆçº¦çš„æ•°æ®ã€‚
    // äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/contracts.html#constructors
    constructor(string memory initMessage) public {
        // æ¥å—ä¸€ä¸ªå­—ç¬¦å˜é‡ `initMessage` 
        // å¹¶ä¸ºåˆçº¦çš„å­˜å‚¨å˜é‡`message` èµ‹å€¼
        message = initMessage;
    }
    // ä¸€ä¸ª public å‡½æ•°æ¥å—å­—ç¬¦å‚æ•°å¹¶æ›´æ–°å­˜å‚¨å˜é‡ `message`
    function update(string memory newMessage) public {
        message = newMessage;
    }
}
```


# 7.2 ä»£å¸
pragma solidity ^0.5.10;
contract Token {
    // ä¸€ä¸ª `address` ç±»æ¯”äºé‚®ä»¶åœ°å€ - å®ƒç”¨æ¥è¯†åˆ«ä»¥å¤ªåŠçš„ä¸€ä¸ªå¸æˆ·ã€‚
    // åœ°å€å¯ä»¥ä»£è¡¨ä¸€ä¸ªæ™ºèƒ½åˆçº¦æˆ–ä¸€ä¸ªå¤–éƒ¨ï¼ˆç”¨æˆ·ï¼‰å¸æˆ·ã€‚
    // äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/types.html#address
    address public owner;
    //  `mapping` æ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨æ•°æ®ç»“æ„ã€‚
    // æ­¤ `mapping` å°†ä¸€ä¸ªæ— ç¬¦å·æ•´æ•°ï¼ˆä»£å¸ä½™é¢ï¼‰åˆ†é…ç»™åœ°å€ï¼ˆä»£å¸æŒæœ‰è€…ï¼‰ã€‚
    // äº†è§£æ›´å¤šï¼š https://solidity.readthedocs.io/en/v0.5.10/types.html#mapping-types
    mapping (address => uint) public balances;
    // äº‹ä»¶å…è®¸åœ¨åŒºå—é“¾ä¸Šè®°å½•æ´»åŠ¨ã€‚
    // ä»¥å¤ªåŠå®¢æˆ·ç«¯å¯ä»¥ç›‘å¬äº‹ä»¶ï¼Œä»¥ä¾¿å¯¹åˆçº¦çŠ¶æ€æ›´æ”¹ä½œå‡ºååº”ã€‚
    // äº†è§£æ›´å¤šï¼š https://solidity.readthedocs.io/en/v0.5.10/contracts.html#events
    event Transfer(address from, address to, uint amount);
    // åˆå§‹åŒ–åˆçº¦æ•°æ®ï¼Œè®¾ç½® `owner`ä¸ºåˆçº¦åˆ›å»ºè€…çš„åœ°å€ã€‚
    constructor() public {
        // æ‰€æœ‰æ™ºèƒ½åˆçº¦ä¾èµ–å¤–éƒ¨äº¤æ˜“æ¥è§¦å‘å…¶å‡½æ•°ã€‚
        // `msg` æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼ŒåŒ…å«äº†ç»™å®šäº¤æ˜“çš„ç›¸å…³æ•°æ®ï¼Œ
        // ä¾‹å¦‚å‘é€è€…çš„åœ°å€å’ŒåŒ…å«åœ¨äº¤æ˜“ä¸­çš„ ETH æ•°é‡ã€‚
        // äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/units-and-global-variables.html#block-and-transaction-properties
        owner = msg.sender;
    }
    // åˆ›å»ºä¸€äº›æ–°ä»£å¸å¹¶å‘é€ç»™ä¸€ä¸ªåœ°å€ã€‚
    function mint(address receiver, uint amount) public {
        // `require` æ˜¯ä¸€ä¸ªç”¨äºå¼ºåˆ¶æ‰§è¡ŒæŸäº›æ¡ä»¶çš„æ§åˆ¶ç»“æ„ã€‚
        // å¦‚æœ `require` çš„æ¡ä»¶ä¸º `false`ï¼Œåˆ™å¼‚å¸¸è¢«è§¦å‘ï¼Œ
        // æ‰€æœ‰åœ¨å½“å‰è°ƒç”¨ä¸­å¯¹çŠ¶æ€çš„æ›´æ”¹å°†è¢«è¿˜åŸã€‚
        // å­¦ä¹ æ›´å¤š: https://solidity.readthedocs.io/en/v0.5.10/control-structures.html#error-handling-assert-require-revert-and-exceptions
        // åªæœ‰åˆçº¦åˆ›å»ºäººå¯ä»¥è°ƒç”¨è¿™ä¸ªå‡½æ•°
        require(msg.sender == owner, "You are not the owner.");
        // å¼ºåˆ¶æ‰§è¡Œä»£å¸çš„æœ€å¤§æ•°é‡
        require(amount < 1e60, "Maximum issuance exceeded");
        // å°† "æ”¶æ¬¾äºº"çš„ä½™é¢å¢åŠ "é‡‘é¢"
        balances[receiver] += amount;
    }
    // ä»ä»»ä½•è°ƒç”¨è€…é‚£é‡Œå‘é€ä¸€å®šæ•°é‡çš„ä»£å¸åˆ°ä¸€ä¸ªåœ°å€ã€‚
    function transfer(address receiver, uint amount) public {
        // å‘é€è€…å¿…é¡»æœ‰è¶³å¤Ÿæ•°é‡çš„ä»£å¸ç”¨äºå‘é€
        require(amount <= balances[msg.sender], "Insufficient balance.");
        // è°ƒæ•´ä¸¤ä¸ªå¸æˆ·çš„ä½™é¢
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        // è§¦å‘ä¹‹å‰å®šä¹‰çš„äº‹ä»¶ã€‚
        emit Transfer(msg.sender, receiver, amount);
    }
}


# 7.3 å”¯ä¸€çš„æ•°å­—èµ„äº§
pragma solidity ^0.5.10;
// ä»å…¶å®ƒæ–‡ä»¶å‘å½“å‰åˆçº¦ä¸­å¯¼å…¥ç¬¦å·ã€‚
// æœ¬ä¾‹ä½¿ç”¨ä¸€ç³»åˆ—æ¥è‡ª OpenZeppelin çš„è¾…åŠ©åˆçº¦ã€‚
// äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/layout-of-source-files.html#importing-other-source-files
import "../node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "../node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "../node_modules/@openzeppelin/contracts/introspection/ERC165.sol";
import "../node_modules/@openzeppelin/contracts/math/SafeMath.sol";
// `is` å…³é”®å­—ç”¨äºä»å…¶å®ƒå¤–éƒ¨åˆçº¦ç»§æ‰¿å‡½æ•°å’Œå…³é”®å­—ã€‚
// æœ¬ä¾‹ä¸­ï¼Œ`CryptoPizza` ç»§æ‰¿ `IERC721` å’Œ `ERC165` åˆçº¦ã€‚
// äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/contracts.html#inheritance
contract CryptoPizza is IERC721, ERC165 {
    // ä½¿ç”¨ OpenZeppelin's SafeMath åº“æ¥å®‰å…¨æ‰§è¡Œç®—æ•°æ“ä½œã€‚
    // äº†è§£æ›´å¤šï¼šhttps://docs.openzeppelin.com/contracts/2.x/api/math#SafeMath
    using SafeMath for uint256;
    // Solidity è¯­è¨€ä¸­çš„å¸¸é‡çŠ¶æ€å˜é‡ä¸å…¶ä»–è¯­è¨€ç±»ä¼¼ã€‚
    // ä½†æ˜¯å¿…é¡»ç”¨ä¸€ä¸ªè¡¨è¾¾å¼ä¸ºå¸¸é‡èµ‹å€¼ï¼Œè€Œè¿™ä¸ªè¡¨è¾¾å¼æœ¬èº«å¿…é¡»åœ¨ç¼–è¯‘æ—¶æ˜¯ä¸€ä¸ªå¸¸é‡ã€‚
    // Learn more: https://solidity.readthedocs.io/en/v0.5.10/contracts.html#constant-state-variables
    uint256 constant dnaDigits = 10;
    uint256 constant dnaModulus = 10 ** dnaDigits;
    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    // Struct types let you define your own type
    // Learn more: https://solidity.readthedocs.io/en/v0.5.10/types.html#structs
    struct Pizza {
        string name;
        uint256 dna;
    }
    // Creates an empty array of Pizza structs
    Pizza[] public pizzas;
    // Mapping from pizza ID to its owner's address
    mapping(uint256 => address) public pizzaToOwner;
    // Mapping from owner's address to number of owned token
    mapping(address => uint256) public ownerPizzaCount;
    // Mapping from token ID to approved address
    mapping(uint256 => address) pizzaApprovals;
    // You can nest mappings, this example maps owner to operator approvals
    mapping(address => mapping(address => bool)) private operatorApprovals;
    // Internal function to create a random Pizza from string (name) and DNA
    function _createPizza(string memory _name, uint256 _dna)
        // The `internal` keyword means this function is only visible
        // within this contract and contracts that derive this contract
        // Learn more: https://solidity.readthedocs.io/en/v0.5.10/contracts.html#visibility-and-getters
        internal
        // `isUnique` is a function modifier that checks if the pizza already exists
        // Learn more: https://solidity.readthedocs.io/en/v0.5.10/structure-of-a-contract.html#function-modifiers
        isUnique(_name, _dna)
    {
        // Adds Pizza to array of Pizzas and get id
        uint256 id = SafeMath.sub(pizzas.push(Pizza(_name, _dna)), 1);
        // Checks that Pizza owner is the same as current user
        // Learn more: https://solidity.readthedocs.io/en/v0.5.10/control-structures.html#error-handling-assert-require-revert-and-exceptions
        // note that address(0) is the zero address,
        // indicating that pizza[id] is not yet allocated to a particular user.
        assert(pizzaToOwner[id] == address(0));
        // Maps the Pizza to the owner
        pizzaToOwner[id] = msg.sender;
        ownerPizzaCount[msg.sender] = SafeMath.add(
            ownerPizzaCount[msg.sender],
            1
        );
    }
    // Creates a random Pizza from string (name)
    function createRandomPizza(string memory _name) public {
        uint256 randDna = generateRandomDna(_name, msg.sender);
        _createPizza(_name, randDna);
    }
    // Generates random DNA from string (name) and address of the owner (creator)
    function generateRandomDna(string memory _str, address _owner)
        public
        // Functions marked as `pure` promise not to read from or modify the state
        // Learn more: https://solidity.readthedocs.io/en/v0.5.10/contracts.html#pure-functions
        pure
        returns (uint256)
    {
        // Generates random uint from string (name) + address (owner)
        uint256 rand = uint256(keccak256(abi.encodePacked(_str))) +
            uint256(_owner);
        rand = rand % dnaModulus;
        return rand;
    }
    // Returns array of Pizzas found by owner
    function getPizzasByOwner(address _owner)
        public
        // Functions marked as `view` promise not to modify state
        // Learn more: https://solidity.readthedocs.io/en/v0.5.10/contracts.html#view-functions
        view
        returns (uint256[] memory)
    {
        // Uses the `memory` storage location to store values only for the
        // lifecycle of this function call.
        // äº†è§£æ›´å¤šï¼šhttps://solidity.readthedocs.io/en/v0.5.10/introduction-to-smart-contracts.html#storage-memory-and-the-stack
        uint256[] memory result = new uint256[](ownerPizzaCount[_owner]);
        uint256 counter = 0;
        for (uint256 i = 0; i < pizzas.length; i++) {
            if (pizzaToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
            }
        }
        return result;
    }
    // è½¬ç§» Pizza å’Œå½’å±å…³ç³»åˆ°å…¶å®ƒåœ°å€
    function transferFrom(address _from, address _to, uint256 _pizzaId) public {
        require(_from != address(0) && _to != address(0), "Invalid address.");
        require(_exists(_pizzaId), "Pizza does not exist.");
        require(_from != _to, "Cannot transfer to the same address.");
        require(_isApprovedOrOwner(msg.sender, _pizzaId), "Address is not approved.");
        ownerPizzaCount[_to] = SafeMath.add(ownerPizzaCount[_to], 1);
        ownerPizzaCount[_from] = SafeMath.sub(ownerPizzaCount[_from], 1);
        pizzaToOwner[_pizzaId] = _to;
        // è§¦å‘ç»§æ‰¿è‡ª IERC721 åˆçº¦ä¸­å®šä¹‰çš„äº‹ä»¶ã€‚
        emit Transfer(_from, _to, _pizzaId);
        _clearApproval(_to, _pizzaId);
    }
    /**
     * å®‰å…¨è½¬è´¦ç»™å®šä»£å¸ ID çš„æ‰€æœ‰æƒåˆ°å…¶å®ƒåœ°å€
     * å¦‚æœç›®æ ‡åœ°å€æ˜¯ä¸€ä¸ªåˆçº¦ï¼Œåˆ™è¯¥åˆçº¦å¿…é¡»å®ç° `onERC721Received`å‡½æ•°, 
     * è¯¥å‡½æ•°è°ƒç”¨äº†å®‰å…¨è½¬è´¦å¹¶ä¸”è¿”å›ä¸€ä¸ª magic valueã€‚
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`;
     * å¦åˆ™ï¼Œè½¬è´¦è¢«å›é€€ã€‚
    */
    function safeTransferFrom(address from, address to, uint256 pizzaId)
        public
    {
        // solium-disable-next-line arg-overflow
        this.safeTransferFrom(from, to, pizzaId, "");
    }
    /**
     * å®‰å…¨è½¬è´¦ç»™å®šä»£å¸ ID æ‰€æœ‰æƒåˆ°å…¶å®ƒåœ°å€
     * å¦‚æœç›®æ ‡åœ°å€æ˜¯ä¸€ä¸ªåˆçº¦ï¼Œåˆ™è¯¥åˆçº¦å¿…é¡»å®ç° `onERC721Received` å‡½æ•°ï¼Œ
     * è¯¥å‡½æ•°è°ƒç”¨å®‰å…¨è½¬è´¦å¹¶è¿”å›ä¸€ä¸ª magic value
     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`;
     * å¦åˆ™ï¼Œè½¬è´¦è¢«å›é€€ã€‚
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 pizzaId,
        bytes memory _data
    ) public {
        this.transferFrom(from, to, pizzaId);
        require(_checkOnERC721Received(from, to, pizzaId, _data), "Must implement onERC721Received.");
    }
    /**
     * Internal function to invoke `onERC721Received` on a target address
     * The call is not executed if the target address is not a contract
     */
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 pizzaId,
        bytes memory _data
    ) internal returns (bool) {
        if (!isContract(to)) {
            return true;
        }
        bytes4 retval = IERC721Receiver(to).onERC721Received(
            msg.sender,
            from,
            pizzaId,
            _data
        );
        return (retval == _ERC721_RECEIVED);
    }
    // Burns a Pizza - destroys Token completely
    // The `external` function modifier means this function is
    // part of the contract interface and other contracts can call it
    function burn(uint256 _pizzaId) external {
        require(msg.sender != address(0), "Invalid address.");
        require(_exists(_pizzaId), "Pizza does not exist.");
        require(_isApprovedOrOwner(msg.sender, _pizzaId), "Address is not approved.");
        ownerPizzaCount[msg.sender] = SafeMath.sub(
            ownerPizzaCount[msg.sender],
            1
        );
        pizzaToOwner[_pizzaId] = address(0);
    }
    // Returns count of Pizzas by address
    function balanceOf(address _owner) public view returns (uint256 _balance) {
        return ownerPizzaCount[_owner];
    }
    // Returns owner of the Pizza found by id
    function ownerOf(uint256 _pizzaId) public view returns (address _owner) {
        address owner = pizzaToOwner[_pizzaId];
        require(owner != address(0), "Invalid Pizza ID.");
        return owner;
    }
    // Approves other address to transfer ownership of Pizza
    function approve(address _to, uint256 _pizzaId) public {
        require(msg.sender == pizzaToOwner[_pizzaId], "Must be the Pizza owner.");
        pizzaApprovals[_pizzaId] = _to;
        emit Approval(msg.sender, _to, _pizzaId);
    }
    // Returns approved address for specific Pizza
    function getApproved(uint256 _pizzaId)
        public
        view
        returns (address operator)
    {
        require(_exists(_pizzaId), "Pizza does not exist.");
        return pizzaApprovals[_pizzaId];
    }
    /**
     * Private function to clear current approval of a given token ID
     * Reverts if the given address is not indeed the owner of the token
     */
    function _clearApproval(address owner, uint256 _pizzaId) private {
        require(pizzaToOwner[_pizzaId] == owner, "Must be pizza owner.");
        require(_exists(_pizzaId), "Pizza does not exist.");
        if (pizzaApprovals[_pizzaId] != address(0)) {
            pizzaApprovals[_pizzaId] = address(0);
        }
    }
    /*
     * Sets or unsets the approval of a given operator
     * An operator is allowed to transfer all tokens of the sender on their behalf
     */
    function setApprovalForAll(address to, bool approved) public {
        require(to != msg.sender, "Cannot approve own address");
        operatorApprovals[msg.sender][to] = approved;
        emit ApprovalForAll(msg.sender, to, approved);
    }
    // Tells whether an operator is approved by a given owner
    function isApprovedForAll(address owner, address operator)
        public
        view
        returns (bool)
    {
        return operatorApprovals[owner][operator];
    }
    // Takes ownership of Pizza - only for approved users
    function takeOwnership(uint256 _pizzaId) public {
        require(_isApprovedOrOwner(msg.sender, _pizzaId), "Address is not approved.");
        address owner = this.ownerOf(_pizzaId);
        this.transferFrom(owner, msg.sender, _pizzaId);
    }
    // Checks if Pizza exists
    function _exists(uint256 pizzaId) internal view returns (bool) {
        address owner = pizzaToOwner[pizzaId];
        return owner != address(0);
    }
    // Checks if address is owner or is approved to transfer Pizza
    function _isApprovedOrOwner(address spender, uint256 pizzaId)
        internal
        view
        returns (bool)
    {
        address owner = pizzaToOwner[pizzaId];
        // Disable solium check because of
        // https://github.com/duaraghav8/Solium/issues/175
        // solium-disable-next-line operator-whitespace
        return (spender == owner ||
            this.getApproved(pizzaId) == spender ||
            this.isApprovedForAll(owner, spender));
    }
    // Check if Pizza is unique and doesn't exist yet
    modifier isUnique(string memory _name, uint256 _dna) {
        bool result = true;
        for (uint256 i = 0; i < pizzas.length; i++) {
            if (
                keccak256(abi.encodePacked(pizzas[i].name)) ==
                keccak256(abi.encodePacked(_name)) &&
                pizzas[i].dna == _dna
            ) {
                result = false;
            }
        }
        require(result, "Pizza with such name already exists.");
        _;
    }
    // Returns whether the target address is a contract
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}
æ˜¾ç¤ºå…¨éƒ¨
ğŸ“‹ å¤åˆ¶
å»¶ä¼¸é˜…è¯»
æŸ¥é˜… Solidity å’Œ Vyper æ–‡æ¡£ï¼Œä»¥è·å¾—å…³äºæ™ºèƒ½åˆçº¦çš„æ›´å®Œæ•´æ¦‚è¿°ï¼š

Solidity(opens in a new tab)
Vyper(opens in a new tab)